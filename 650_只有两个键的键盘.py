# -*- coding: utf-8 -*-
"""
Created on Mon May 11 14:06:43 2020

@author: leiya
"""

'''
关于转移公式需要强调的是：转移公式可以理解为求完全分解某个数后的各项质因子的和，
之所以找一个质因子，是因为dp[i]已经涵盖了自然数i的质因子完全（即没有可以继续分的非质数存在）分解后的和，
即各项质因子的和就是最后的最少操作次数。
'''
#dp[i] 通过复制粘贴操作，得到 i 个字符，最少需要几步操作
#质数：指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数
#为什么非得拆解成质因子呢？因为当一个因子还可以分解成更小的因子的时候，那么分解后的结果会更小

#转移公式可以理解为以完全分解公因式后的的各项质因子的和，之所以找一个质因子，是因为dp[i]已经涵盖了质因子的分解后的和
#即各项质因子的和就是最后的最少操作次数
class Solution:
    def minSteps(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        for i in range(2, n+1):
            dp[i] = i
            #此循环在判断j是否为i的质因子，只需要在这里面找到一个符合要求的质因子，因为该质因子对应的另一个质因子一定在前面被求过了
            #该for循环执行结束后如果仍没有进入if说明i是质数，他的次数就是dp[i] = i
            #for j in range(2, i):
            for j in range(2, int(sqrt(i))+1):
                if i % j == 0:
                    dp[i] = dp[j] + dp[i//j]
                    break              
        return dp[-1]